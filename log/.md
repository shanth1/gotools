# `log` Package

A flexible, type-safe, and configurable logging library built on `zerolog`. It supports configuration via options or a struct, multiple writers (console, UDP), context integration, and **full compatibility with the standard `log/slog` library**.

## Usage

### Simple Initialization & Rich Types

The logger supports strong typing for fields (Int, Bool, Duration, Time, Slices, etc.) to prevent allocation overhead.

```go
package main

import (
	"errors"
	"time"
	"github.com/shanth1/gotools/log"
)

func main() {
	logger := log.New(
		log.WithService("my-service"),
		log.WithLevel(log.LevelDebug),
		log.WithCaller(),
	)

	// Rich typing support
	logger.Info().
		Str("status", "ok").
		Int("attempt", 3).
		Dur("latency", 150*time.Millisecond).
		Strs("tags", []string{"api", "v1"}).
		Msg("Request processed")

	logger.Error().
		Err(errors.New("db error")).
		Msg("Critical failure")
}
```

### Initialization from Config

The logger can be initialized from a `log.Config` struct.
**Note:** The logger performs strict validation. If an invalid log level is provided, the application will **panic** at startup to prevent silent failures.

```go
// config.yaml
// level: "debug"     # Valid: trace, debug, info, warn, error, fatal, panic, disabled
// service: "payment"
// console: true      # Pretty printing
// json_output: false

var logCfg log.Config
// ... load config into logCfg ...

// Will panic if config.Level is invalid (e.g. "typo")
logger := log.NewFromConfig(logCfg)
```

### Standard Library (`slog`) Compatibility

You can convert the logger into a standard `*slog.Logger` to use with libraries that expect the standard interface.

```go
import "log/slog"

func main() {
	// Create your configured logger
	logger := log.New(log.WithLevel(log.LevelInfo))

	// Convert to *slog.Logger
	stdLogger := log.ToSlog(logger)

	// Use with standard library
	stdLogger.Info("Using standard slog", "user_id", 42)
}
```
